# Create your views here.
import os
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse, JsonResponse, HttpResponseBadRequest
from django.shortcuts import render
from django.views.decorators.csrf import ensure_csrf_cookie
from django.core.exceptions import ObjectDoesNotExist
from django.core import serializers
from .models import *
import pandas
from collections import defaultdict
import logging
logger = logging.getLogger(__name__)

RECORDING_DIRECTORY = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'recordings')

def index(request):
    return HttpResponse("Welcome to the EEG Project.")

@login_required
@ensure_csrf_cookie
def viewer(request):
    """display the main EEG viewer"""
    if request.user.is_superuser:
        return render(request, 'viewer/expert.html', {})        
    user = User.objects.get(username=request.user)
    task_type = Turker.objects.get(user=user).task_type

    if task_type == "no_feedback":
        return render(request, 'viewer/mturk_without_feedback.html', {})
    else:
        return render(request, 'viewer/mturk_with_feedback.html', {})
    
@login_required
def getUserStatus(request):
    """get the progress of the current user through the task"""
    annotator, created = Annotator.objects.get_or_create(username=request.user.get_username())
    progress = {
        'recording': annotator.current_recording,
        'start_time': float(annotator.current_page_start),
    }
    return JsonResponse(progress)

@login_required
def consentForm(request):
    """display the consent form"""
    return render(request, 'viewer/consent.html', {})

@login_required
def feedback(request):
    """display the end of task feedback page"""
    return render(request, 'viewer/feedback.html', {})

# Create your views here.
@login_required
def getEEGData(request, recording, start_time, window_length):
    """Loads one window of EEG data from CSV file. This data is packaged into
    a JSON response (50-110kb). 
    For this to work, the CSV must have been generated by edf_extract, which 
    pares it down the minimal number of channels and down samples it to consume 
    a very minimal amount of hard disk space (around 40-90mb for an 8 hour recording).

    This method could be optimized, but for our purposes (analyzing sleep spindles
    in EEG) this is more than good enough.
    see also: annotator.js, eeg_processing/signal_processing/edf_extract.py
    """
    annotator, created = Annotator.objects.get_or_create(username=request.user.get_username())
    annotator.current_page_start = start_time
    annotator.save() # keep track of where the user is in the task

    start_time = int(start_time)
    window_length = int(window_length) # seconds of EEG recording per window
    # convention -- recording name should match the CSV filename
    csv_fp = os.path.join(os.path.dirname(os.path.abspath(__file__)), 
        os.path.join(RECORDING_DIRECTORY, recording+'.csv'))
    # sample rate is appended to the recording name as a suffix 
    # ex. excerpt1_50.csv has a 50hz sample rate
    sample_rate = int(recording[recording.rfind('_')+1:])
    skip_samples = sample_rate * start_time # number of CSV rows to skip
    num_samples_to_send = sample_rate * window_length
    # note, this could be improved by writing a pandas parser for EDF, or replacing Pandas with an EDF parser
    df = pandas.read_csv(csv_fp, skiprows=xrange(1, skip_samples), nrows=num_samples_to_send)
    response = df.to_dict(orient='list')
    response_columns = df.columns.values.tolist()
    request.session['viewing_answer'] = False # new screen, so user isn't viewing answer anymore

    # check for empty dataframe (occurs at the end of the file)
    if not response[response_columns[0]]:
        return JsonResponse({}) # return an empty response if past file's end

    # dict loses the original order, so send column list for reconstruction purposes
    response['ordered_channels'] = [col for col in response_columns if not col.find('time')>-1]
    return JsonResponse(response)

@login_required
def saveFeature(request):
    """called whenever a user highlights a spindle or a k-complex, this method
    stores the feature selection in the database
    """
    if request.session.get('viewing_answer', False):
        return HttpResponseBadRequest("Cannot save features while the answer is displayed")

    if not request.method == 'POST':
        return HttpResponseBadRequest("This view accepts POST requests only")

    # grab the annotation from the request object 
    feature_type = request.POST['feature_type']
    channel = request.POST['channel']
    time_start = request.POST['time_start']
    time_end = request.POST['time_end']
    certainty = request.POST['certainty_score']
    annotator_username = request.user.get_username()
    recording_name = request.POST['recording_name']
    # load this window in the database, or create one if this window has never been
    # annotated before. 
    annotator, created = Annotator.objects.get_or_create(username=annotator_username)
    recording, created = Recording.objects.get_or_create(name=recording_name)

    logger.debug("SAVING FEATURE -- user: {} recording: {} time_start: {}".format(annotator_username, recording_name, time_start))
    # save the annotation to the database
    annotation_feature = Feature(
        recording=recording, feature_type=feature_type, channel=channel, 
        start=time_start, end=time_end, certainty=1.0, annotator=annotator)
    annotation_feature.save()
    return HttpResponse("", status=200)

@login_required
def deleteFeature(request):
    """called whenever a user double clicks on a highlighted section to remove
    it, this method deletes that highlight from the database
    """
    if request.method == 'POST':
        # grab the annotation from the request object 
        time_start = request.POST['time_start']
        time_end = request.POST['time_end']
        channel = request.POST['channel']
        annotator_username = request.user.get_username()
        recording_name = request.POST['recording_name']
        # should be enough to ensure that Turkers can't delete expert annotations?
        annotator = Annotator.objects.get(username=annotator_username)
        recording = Recording.objects.get(name=recording_name)

        # delete the annotation from the database
        annotation_feature = Feature.objects.get(
            start=time_start,end=time_end,channel=channel,annotator=annotator,recording=recording)
        annotation_feature.delete()
        return HttpResponse("")
    else:
        return HttpResponseBadRequest("Use post")

@login_required
def getAnnotations(request):
    """gets all of the annotations in the window.
    In mTurk mode this is used to display answers
    In expert mode this is used to display previous annotations
    """
    recording_name = request.GET.get('recording_name', '')
    window_start = request.GET.get('window_start', 0)
    window_end = request.GET.get('window_end', 0)
    # django recives this value as unicode for some reason
    if request.GET.get('displaying_answer', False) == 'true':
        displaying_answer = True
    else:
        displaying_answer = False

    if displaying_answer:
        request.session['viewing_answer'] = True

    # in mTurk view, get expert annotations to display as answers
    if displaying_answer:
        username = "expert"
    else:
        username = request.user.get_username()

    annotator = Annotator.objects.get(username=username)
    recording, created = Recording.objects.get_or_create(name=recording_name)
    # Django query sets use lazy evaulation, using list forces them to evaluate
    features = list(Feature.objects.filter(recording=recording, annotator=annotator).filter(start__gte=window_start).filter(end__lte=window_end))
    feature_list = [ob.as_dict() for ob in features]

    data = {'features': feature_list}
    return JsonResponse(data)